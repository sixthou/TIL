# 15장. 구글 드라이브 설계
- 드라이브 서비스
  - 파일 저장 및 동기화 서비스
  - 문서, 사진, 비디오 기타 파일을 클라우드에 보관할 수 있따.
  - 컴퓨터, 스마트폰, 태블릿 등 멀티 플랫폼을 지원한다.
## 설계 범위 확정
- 파일 추가
- 파일 다운로드
- 여러 단말의 파일 동기화
- 파일 갱신 이력 조회
- 파일 공유
- 알림 서비스
- 안정성 : 데이터 손실 방지
- 빠른 동기화 속도
- 네트워크 태역폭
- 규모 확장성
- 높은 가용성

## 개력적 설계안
- API
  - 사용자 인증, HTTP 프로토콜 사용 필요.  
  - 파일 업로드 API
    - 단순 업로드
    - 이어 올리기
      1. 이어 올리기 URL을 받기 위한 최초 요청 전송
      2. 데이터 업로드하고 업로드 상태 모니터링
      3. 업로드에 장애가 발생하면 장애 발생시점부터 업로드 재시작
  - 파일 다운로드 API
  - 파일 갱신 히스토리 제공 API
- 동기화 충돌
  - 두명 이상의 사용자가 같은 파일이나 폴더를 동시에 업데이트하고자 하는 경우.
  - 먼저 처리되는 변경을 성공한 것으로 보고, 나중에 처리되는 변경은 충돌이 발생한것으로 표시한다.
- 블록 저장소 서버
  - 파일 블록을 클라우드 저장소에 업로드 하는 서버
  - 파일을 여러개의 블록으로 나눠 저장하며, 각 블록은 고유한 해시 값이 할당됨.
  - 해시값은 메타데이터 DB에 저장됨
  - 각 블록은 독릭접 객체로 취급
- 아카이빙 저장소
  - 올랫동안 사용되지 않은 비활성 데이터를 저장하기 위한 시스템
- 메타데이터 데이터베이스 
  - 사용자, 파일, 블록, 버전 등의 메타데이터 정보 관리
  - 오직 메타데이터만 둔다.
- 오프라인 사용자 백업 큐
  - 클라이언트가 접속 중이 아닐떄 큐에 변경 정보를 두어 접속시 동기화할 수 있도록 한다.
## 상세설계
- 블록 저장소 서버
  - 업데이트가 일어날 때마다 파일을 서버로 보내면? -> 네트워크 대역폭 낭비
  - 최적화 방법
    - 델타 동기화
      - 수정이 일어난 블록만 동기화
    - 압축
      - 블록 단위로 압축해 데이터 크기를 줄인다.
    - 신규 파일 추가시 동작
      1. 주어진 파일을 작은 블록들로 분할
      2. 각 블록을 압축한다.
      3. 클라우드 저장소로 보내기전에 암호화한다.
      4. 클라우드 저장소로 보낸다.

- 높은 일관성 요구사항
  - 강한 일관성 모델 : 같은 파일이 단말이나 사용자에 따라 보이는 것을 허용할 수 없다.
  - 캐시에 보관된 사본과 데이터베이스의 원본이 일치해야한다.
  - 데이터베이스에 보관된 원본에 변경이 발생하면 캐시에 있는 사본을 무효화한다.

- 업로드 절차
  - 두개의 요청이 병렬적으로 요청됨 
  - 파일 메타데이터 추가
    1. 클라이언트 1이 새 파일의 메타데이터를 추가하기 위한 요청 전송
    2. 새 파일의 메타데이터를 데이터베이스에 저장하고 업로드 상태를 대기중으로 변경
    3. 새 파일이 추가되엇음을 알림 서비스에 통지
    4. 알림 서비스는 관련된 클라이언트에게 파일이 업로드되고 있음을 알림
  - 파일을 클라우드 저장소에 업로드
    1. 클라이어트 1이 파일을 블록 저장소 서버에 업로드
    2. 블록 저장소 서버는 파일을 블록 단위로 쪼갠 다음 압축하고 암호화한 다음에 클라우드 저장소에 전송
    3. 업로드가 끝나면 클라우드 스토리지는 완료 콜백을 호출. 이 콜백 호출은 API 서버로 전송됨
    4. 메타데이터 DB에 기록된 해당 파일의 상태를 완료로 변경
    5. 알림 서비스에 파일 업로드가 끝났음을 통지
    6. 알림 서비스는 관련된 클라이언트에게 파일 업로드가 끝났음을 알림

- 다운로드 절차
  1. 알림 서비스가 클라이언트 2에게 누군가 파일을 변경했음을 알림
  2. 알림을 확인한 클라이언트 2는 새로운 메타데이터를 요청
  3. API 서버는 메타데이터 데이터베이스에게 새 메타데이터 요청
  4. API 서버에게 새 메타데이터가 반환됨
  5. 클라이언트 2에게 새 메타데이터가 반환됨
  6. 클라이언트 2는 새 메타데이터를 받는 즉시 블록 다운로드 요청 전송
  7. 블록 저장소 서버는 클라우드 저장소에서 블록 다운로드
  8. 클라우드 저장소는 블록 서버에 요청된 블록 반환
  9. 블록 저장소 서버는 클라이언트에게 요청된 블록 반환. 클라이언트 2는 전송된 블록을 사용하여 파일 재구성

- 알림 서비스
  - 클라이언트는 로컬에서 파일이 수정됨을 감지하면 다른 클라이언트에게 그 사실을 알려 충돌 가능성을 줄여야 한다.
  - 이벤트 데이터를 클라이언트들로 보내는 서비스
    - 롱 폴링
      - 각 클라이언트는 알림 서버와 롱 폴링용 연결을 유지하다가 특정 파일에 대한 변경을 감지하면 연견을 끊는다.
      - 메타데이터 서버에 연결해 파일의 최신 내역을 다운로드 한다

- 저장소 공간 절약
  - 파일 갱신 이력을 보존하고 안정성을 보장하기 위해서는 파일의 여러 버전을 여러 데이터센터에 보관할 필요가 있다.
  - 중복제거
    - 두 블록이 같은 블록인지 해시값을 비교해 판다.
    - 중복된 파일 블록을 계정 차원에서 제거
  - 지능적 백업 전략
    - 한도 설정 : 보관해야할 파일 버전 개수에 상한을 두는것.
    - 중요한 버전만 보관 : 파일이 자주 바뀌는 경우
  - 자주 쓰이지 않는 데이터는 아카이빙 저장소로 옮긴다.

- 장애 처리
  - 블록 저장소 서버 장애
    - 다른 서버가 미완료 상태 또는 대기 상태인 작업을 이어 받아서 작업.
  - 클라우드 저장소 장애
    - 다른 지역에서 파일을 가져온다.
  - 메타데이터 캐시 장애
    - 캐시 서버도 다중화
  - 알림 서비스 장애
    - 접속 중인 모든 사용자는 알림서버와 롱 폴링을 하나씩 유지한다.
    - 동시에 폴링 연결을 복구하는거는 불가능 -> 복구가 상대적으로 느릴 수 있다.
  - 오프라인 사용자 백업 큐 장애
    - 큐도 다중화 필요
    - 두족중인 클라이언트들은 백업 큐로 구독 관계를 재설정 해야됨.
## 마무리
