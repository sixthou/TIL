# Chater 4. 처리율 제한 장치의 설계

# 처리율 제한 장치(Rate limiter)
  클라이언트 또는 서비스가 트래픽의 처리율을 제어하기 위한 장치

### 장점
- DoS 공격에 의한 자원 고갈을 방지
- 비용절감
  - 처리율 제한으로 서버의 수를 적게 유지
  - 우선순위가 높은 API에 더 많은 자원을 할당할 수 있다.
- 서버 과부화 방지
  - Bot이나 사용자의 잘못된 이용 패턴에 의한 요청 방지

### 어디에 설치해야 할까?
1. API서버
   ![1.png](../%EB%8C%80%EA%B7%9C%EB%AA%A8%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84%20%EA%B8%B0%EC%B4%88/img/ch4/1.png)
2. 미들웨어
   ![2.png](../%EB%8C%80%EA%B7%9C%EB%AA%A8%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84%20%EA%B8%B0%EC%B4%88/img/ch4/2.png)
- 일반적으로는 `API 게이트웨이라`는 컴포넌트로 구현
- `처리율제한`, `SSL 종단`, `사용자 인증`, `IP 허용 목록 관리` 수행

--- 
# 처리율 제한 알고리즘

## 토큰 버킷 알고리즘
- 간단하고 이해도가 높아 보편적으로 사용
  ![3.png](../%EB%8C%80%EA%B7%9C%EB%AA%A8%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84%20%EA%B8%B0%EC%B4%88/img/ch4/3.png)
### 동작원리
1. 버킷에 사전 설정된 토큰이 주기적으로 채워진다. 토큰은 요청이 처리될떄 사용됨.
2. 요청이 도착하면 버킷에 토큰이 있는지 검사 
3. 토큰이 있으면 요청 전달
4. 토큰이 없으면 요청은 버려짐
### 특징
- `버킷의 크기`와 `토큰 공급률` 지정 필요
- 일반적으로 API Endpoint 마다 버킷을 둔다.
- 버킷 설정에 따라 `처리율 제한 범위`를 지정할 수 있다.
### 장점
- 구현이 쉽다.
- 메모리 사용이 효율적이다.
- 짧은 시간 집중된 트래픽 처리가 가능하다.
### 단점
- 두개의 인자 `버킷의 크기`와 `토큰 공급률` 지정이 필요해 튜닝이 까다롭다.


## 누출 버킷 알고리즘
- FIFO 큐로 구현한다.
  ![4.png](../%EB%8C%80%EA%B7%9C%EB%AA%A8%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84%20%EA%B8%B0%EC%B4%88/img/ch4/4.png)
### 동작원리
1. 요청이 도착하면 큐가 가득차 있는지 확인
2. 빈자리가 있으면 큐에 추가
3. 빈자리가 없으면 요청은 버려진다.
4. 지정된 시간마다 큐에서 요청을 꺼내 처리한다.
### 특징
- `버킷의 크기`와 `토큰 공급률` 지정 필요
### 장점
- 메모리 사용량 측면 효율적
- `안정된 출력`이 필요 경우 적합하다. 
### 단점
- 단시간에 많은 트래픽이 오는 경우 **최신 요청이 버려진다.**
- 두개의 인자 `버킷의 크기`와 `토큰 공급률` 지정이 필요해 튜닝이 까다롭다.

## 고정 윈도 카운터 알고리즘
- 타임라인을 고정 간격 윈도로 나누고, 각 윈도마다 카운터를 붙인다.
  ![5.png](../%EB%8C%80%EA%B7%9C%EB%AA%A8%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84%20%EA%B8%B0%EC%B4%88/img/ch4/5.png)
### 동작원리
1. 각 윈도마다 카운터를 붙인다.
2. 요청이 들어오면 카운터 값 1씩 증가한다.
3. 카운터 값이 `임계치`에 도달하며 새로운 윈도가 열릴때까지 요청은 버려진다.
### 장점
- 메모리 효율이 좋다.
- 이해하기 쉽다.
- 윈도우 닫히는 시점에 카운터를 초기화해 특정 트래픽 처리에 적합하다. 
### 단점
- 윈도우 경계 부근에 트래픽이 몰리는 경우, 기대 시스템 한도보다 많은 요청이 처리된다.

## 이동 윈도 로깅 알고리즘
- 요청이 들어온 시간을 로깅한다.
  ![6.png](../%EB%8C%80%EA%B7%9C%EB%AA%A8%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84%20%EA%B8%B0%EC%B4%88/img/ch4/6.png)
### 동작원리
1. 새 요청이 오면 만료된 타임스탬프 제거
2. 새 요청의 타임스탬프를 로그에 추가
3. 로그의 크기가 허용치보다 같거나 작으면 요청을 시스템에 전달
### 장점
- 어느순간의 윈도를 보더라도, 허용되는 요청의 갯수는 시스템 처리율 한도를 넘지 않는다.
### 단점
- 다량의 메모리를 사용한다.

## 이동 윈도 카운터 알고리즘
- `고정 윈도 카운터 알고리즘`과 `이동 윈도 로깅 알고리즘`의 결합
  ![7.png](../%EB%8C%80%EA%B7%9C%EB%AA%A8%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84%20%EA%B8%B0%EC%B4%88/img/ch4/7.png)
### 동작원리
1. 현재 1분간의 요청수 + 직전 1분간의 요청 수 * 이동 윈도와 직전 1분이 겹치는 비율을 계산한다.
2. 임계값을 넘지않는 요청은 전달된다.
3. 임계값을 초과한 요청은 버려진다.
### 장점
- 평균 처리율에 따라 현재 윈도의 상태를 계산해 짧은 시간에 몰리는 트래픽에도 잘 대응한다.
- 메모리 효율이 좋다.
### 단점
- 직전 시간대에 도착한 요청이 균등하게 분포되어 잇다고 가정한 상태에서 추정치를 계산하기 때문에 다소 느슨하다.
---
# 아키텍쳐
- 처리율 제한 알고리즘의 핵심 
  - 요청을 추적할 수 있는 카운터를 생성하고 -> 한도를 넘어서 도착한 요청을 거부하는 것

> 카운터를 어디에 보관할 것인가? => `캐시`가 바람직!
- 메모리상에 동작해 빠르다
- 시간을 기반한 만료정책 지원
- 계략적 구조
  ![8.png](../%EB%8C%80%EA%B7%9C%EB%AA%A8%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84%20%EA%B8%B0%EC%B4%88/img/ch4/8.png)
### 동작원리
1. `클라이언트`가 `처리율 제한 미들웨어`에 요청을 보낸다.
2. `처리율 제한 미들웨어`는 레디스의 지정 버킷에서 카운터를 가져와 한도에 도달했는지 아닌지를 검사한다.
3. 한도에 도달했으면 요청은 거부된다.
4. 한도에 도달하지 않았으면 API 서버에 전달한다. `처리율 제한 미들웨어`는 카운터를 증가 후 레디스에 저장한다.

### 처리율 한도 초과 트래픽 처리
- API는 HTTP 429(too many request)을 클라이언트에 보낸다.
  - 클라이언트는 HTTP 응답헤더를 통해 처리율 제한에 걸렸는지를 판단할 수 있다.
- 한도에 제한에 걸린 메시지는 큐에 보관할 수도 있다.

## 상세 설계
![9.png](../%EB%8C%80%EA%B7%9C%EB%AA%A8%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84%20%EA%B8%B0%EC%B4%88/img/ch4/9.png)

### 동작원리
1. `클라이언트`가 요청을 보내면 요청은 먼저 `처리율 제한 미들웨어`에 도달
2. `처리율 제한 미들웨어`는 `제한 규칙`을 `캐시`에서 가져온다. `레디스`에서 `카운터`와 마지막 요청의 `타임스탬프`를 가져온다.
3. 가져온 값을 근거로 결정을 내린다.
   1. 처리율 제한에 걸리지 않은 경우 -> API 서버로 보낸다.
   2. 처리율 제한에 걸린 경우 -> 429 too many request에러를 클라이언트에 보낸다.
   3. 요청은 버리거단 큐에 저장한다.

## 분산 환경에서의 구현
- `경쟁 조건`과 `동기화 문제`를 해결해야한다.

### 경쟁조건
- 경쟁 조건 문제의 가장 널리 알려진 해결책은 `락`이지만 성능을 떨어트리는 문제가 있다.
- `루아 스크립트`나 `정렬 집합`이라 불리는 레디스 자료구조 사용

### 동기화 이슈
- 사용자가 늘어나면 처리율 제한 장치 서버를 여러대 두개 되면서 동기화가 필요해진다.
- 웹 계층은 무상태 이므로 동기화 하지 않으면 처리율 제한 처리를 올바르게 수행할 수 없다.

#### 동기화 이슈 해결책
- 고정세션 활용
  - 같은 클라이언트의 요청은 항사 같은 처리율 제한 장치로 보내도록
  - 규모 확장 불가능, 유연하지도 않아 좋지 않다.
- 중앙 집중형 데이터 저장소(레디스)
  - 처리율 제한장치가 여러개라도 하나의 데이터를 사용
  - 규모 확장이 가능하고, 유연하다.
