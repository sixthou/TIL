# 빈 스코프
```
1. 빈 스코프란
2. 싱글톤 스코프
3. 프로토타입 스코프
4. 웹 스코프
```
## 1.빈 스코프란
- 빈 스코프란? 빈이 존재할 수 있는 범위.

### **스프링이 지원하는 스코프**
- **싱글톤** : 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 법위의 스코프
- **프로토타입** : 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 짧은 범위의 스코프
- **웹 관련 스코프**
  - **request** : 웹 요청이 들어오고 나갈때 까지 유지되는 스코프
  - **session** : 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프
  - **application** : 웹의 서블릿 컨텍스와 같은 범위로 유지되는 스코프

## 2.싱글톤
- 스프링의 기본 스코프
- 싱글톤 빈 요청
  1. 싱글톤 스코프의 빈을 스프링 컨테이너에 요청한다.
   2. 스프링 컨테이너는 본인이 관리하느 스프링 빈을 반환한다.
   3. 이후 스프링 컨테이너에 같은 요청이 와도 같은 객체 인스턴스의 스프링 빈을 반환한다.
- 


## 3.프로토타입
- @Scope("protoryoe") 으로 지정
- 스프링 컨테이너에 조회하면 스프링 컨테이너는 항상 새로운 인스턴스를 생성해서 반환한다.
- 스프링컨테이너는 프로토타입 빈의 생성과 의존관계 주입, 초기화까지만 관여한다.
-  프로토타입 빈 요청
  1. 프로토타입 스코프의 빈을 스프링 컨테이너에 요청한다.
  2. 스프링 컨테이너는 이 시점에 프로토타입 빈을 생성하고, 필요한 의존관계를 주입한다.
  3. 스프링 컨테이넌느 생성한 프로토타입 빈을 클라이언트에 반환한다.
  4. 스프링 컨터에너에 같은 요청이 오면 항상 새로운 프로토타입 빈을 생성해서 반환한다.
- **스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다.**
- 프로토타입 빈을 관리할 책임은 프로토타입 빈을 받은 클라이언트에 있다.
- `@PreDestory`같은 종료 메서드가 호출되지 않는다. 종료 메서드에 대한 호출은 클라이언트가 직접 해야된다.

### 싱글톤에서 프로토타입을 사용할 경우.
- Dependency Lookup 프토토타입 빈을 컨테이너에서 찾아주는 역할
- `ObjectProvider`, `Provider`을 사용해서 주입 받는 방버을 사용하자.

## 4. 웹 스코프
- 웹 환경에서만 동작한다.
- 스프링이 해당 스코프의 종료시점까지 관리한다.(종료 메소드가 호출된다.)

- **웹 관련 스코프 종료**
  - **request** : HTTP 요청 하나가 들어오고 나갈 떄 까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 인스턴스가 생성되고, 관리된다.
  - **session** : HTTP Sesseion과 동일한 생명주기를 가지는 스코프
  - **application** : 웹의 서블릿 컨텍스와 동일한 생명주기를 갖는 스코프
  - **websocket** : 웹 소켓과 동일한 생명주기를 가지느 스코프

### request 스코프
- `@Scope(vlaue = "request")`를 사용해서 지정.
- HTTP 요청 당 하나씩 생성되고, HTTP 요청이 끝나는 시점에 소멸된다.
- 실제 고객의 요청이 와야 생성되는 스코프이다.
- Provider, 프록시를 사용해서 실행시점 오류를 해결한다.

### 스코프와 프록시
```java
@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class MyLogger {
```
- proxyMode = ScopedProxyMode.TARGET_CLASS를 추가한다.
- 적용대상이 인터페이스명 `INTERFACES`
- 적용대상이 클래스면 `TARGET_CLASS`
- 가짜 프록시 클래스를 만들어두고, HTTP Request와 상관없이 가짜 프록시 클래스를 다른 빈에 미리 주입해 줄 수 있다.
- **CGLIB** 라이브러리로 클래스를 상속받은 가짜 프록시 객체를 만들어 주입한다.
- **가짜 프록시 객체는 요청이 오면 그때 내부에서 진짜 빈을 요청하는 위임로직을 수행한다.**
- 가짜 프록시 객체는 원본 클래스를 상속 받아서 만들어졌기 때문에 이 객체를 사용하는 클라이언트는 원본인지 아닌지 모르며, 동일하게 사용한다.(다형성)
- 객체 조회를 꼭 필요한 시점까지 지연 처리 할 수 잇다.